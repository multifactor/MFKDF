/**
 * @file MFKDF Policy Setup
 * @copyright Multifactor, Inc. 2022–2025
 *
 * @description
 * Setup MFKDF key derivation policy
 *
 * @author Vivek Nair (https://nair.me) <vivek@nair.me>
 */

const setupKey = require('../setup/key').key
const validate = require('./validate').validate

/**
 * Validate and setup a policy-based multi-factor derived key
 *
 * @example
 * // setup key that can be derived from passwordA AND (passwordB OR passwordC)
 * const setup = await mfkdf.policy.setup(
 *   await mfkdf.policy.and(
 *     await mfkdf.setup.factors.password('passwordA', { id: 'passwordA' }),
 *     await mfkdf.policy.or(
 *       await mfkdf.setup.factors.password('passwordB', { id: 'passwordB' }),
 *       await mfkdf.setup.factors.password('passwordC', { id: 'passwordC' })
 *     )
 *   )
 * )
 *
 * // derive key with passwordA and passwordC (or passwordA and passwordB)
 * const derive = await mfkdf.policy.derive(setup.policy, {
 *   passwordA: mfkdf.derive.factors.password('passwordA'),
 *   passwordC: mfkdf.derive.factors.password('passwordC'),
 * })
 *
 * setup.key.toString('hex') // -> e16a…5263
 * derive.key.toString('hex') // -> e16a…5263
 *
 * @param {MFKDFFactor} factor - Base factor used to derive this key
 * @param {Object} [options] - Configuration options
 * @param {string} [options.id] - Unique identifier for this key; random UUIDv4 generated by default
 * @param {number} [options.threshold] - Number of factors required to derive key; factors.length by default (all required)
 * @param {Buffer} [options.salt] - Cryptographic salt; generated via secure PRG by default (recommended)
 * @returns {MFKDFDerivedKey} A multi-factor derived key object
 * @author Vivek Nair (https://nair.me) <vivek@nair.me>
 * @since 0.16.0
 * @memberOf policy
 */
async function setup(factor, options) {
  const key = await setupKey([factor], options)
  if (!validate(key.policy)) {
    throw new RangeError('policy contains duplicate ids')
  }
  return key
}
export { setup }
